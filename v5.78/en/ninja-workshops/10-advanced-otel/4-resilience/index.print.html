<!doctype html><html lang=en dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=print><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.134.3"><meta name=generator content="Relearn 7.2.1"><meta name=description content="We’ll explore how to use OpenTelemetry Collector’s file_storage extension to enhance the resilience of your telemetry pipeline. Specifically, we’ll demonstrate how this extension helps with checkpointing, managing retries, and handling temporary failures effectively.
By implementing this configuration, your OpenTelemetry Collector can reliably store intermediate states on disk, preventing data loss during network failures and enabling the collector to resume operations seamlessly.
Tip This solution will work for metrics as long as the connection downtime is brief—up to 15 minutes. If the downtime exceeds this, the backend may still drop data due to timing mismatches. For logs, we’re planning to implement a more enterprise-ready solution in one of the upcoming collector releases."><meta name=author content><meta name=twitter:card content="summary"><meta name=twitter:title content="4. Building In Resilience :: Splunk Observability Cloud Workshops"><meta name=twitter:description content="We’ll explore how to use OpenTelemetry Collector’s file_storage extension to enhance the resilience of your telemetry pipeline. Specifically, we’ll demonstrate how this extension helps with checkpointing, managing retries, and handling temporary failures effectively.
By implementing this configuration, your OpenTelemetry Collector can reliably store intermediate states on disk, preventing data loss during network failures and enabling the collector to resume operations seamlessly.
Tip This solution will work for metrics as long as the connection downtime is brief—up to 15 minutes. If the downtime exceeds this, the backend may still drop data due to timing mismatches. For logs, we’re planning to implement a more enterprise-ready solution in one of the upcoming collector releases."><meta property="og:url" content="https://splunk.github.io/observability-workshop/v5.78/en/ninja-workshops/10-advanced-otel/4-resilience/index.html"><meta property="og:site_name" content="Splunk Observability Cloud Workshops"><meta property="og:title" content="4. Building In Resilience :: Splunk Observability Cloud Workshops"><meta property="og:description" content="We’ll explore how to use OpenTelemetry Collector’s file_storage extension to enhance the resilience of your telemetry pipeline. Specifically, we’ll demonstrate how this extension helps with checkpointing, managing retries, and handling temporary failures effectively.
By implementing this configuration, your OpenTelemetry Collector can reliably store intermediate states on disk, preventing data loss during network failures and enabling the collector to resume operations seamlessly.
Tip This solution will work for metrics as long as the connection downtime is brief—up to 15 minutes. If the downtime exceeds this, the backend may still drop data due to timing mismatches. For logs, we’re planning to implement a more enterprise-ready solution in one of the upcoming collector releases."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta itemprop=name content="4. Building In Resilience :: Splunk Observability Cloud Workshops"><meta itemprop=description content="We’ll explore how to use OpenTelemetry Collector’s file_storage extension to enhance the resilience of your telemetry pipeline. Specifically, we’ll demonstrate how this extension helps with checkpointing, managing retries, and handling temporary failures effectively.
By implementing this configuration, your OpenTelemetry Collector can reliably store intermediate states on disk, preventing data loss during network failures and enabling the collector to resume operations seamlessly.
Tip This solution will work for metrics as long as the connection downtime is brief—up to 15 minutes. If the downtime exceeds this, the backend may still drop data due to timing mismatches. For logs, we’re planning to implement a more enterprise-ready solution in one of the upcoming collector releases."><meta itemprop=dateModified content="2025-02-05T14:06:34+00:00"><meta itemprop=wordCount content="679"><title>4. Building In Resilience :: Splunk Observability Cloud Workshops</title>
<link href=https://splunk.github.io/observability-workshop/v5.78/en/ninja-workshops/10-advanced-otel/4-resilience/index.html rel=canonical type=text/html title="4. Building In Resilience :: Splunk Observability Cloud Workshops"><link href=/observability-workshop/v5.78/images/favicon.ico?1738773632 rel=icon type=image/x-icon sizes=any><link href=/observability-workshop/v5.78/css/fontawesome-all.min.css?1738773632 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/observability-workshop/v5.78/css/fontawesome-all.min.css?1738773632 rel=stylesheet></noscript><link href=/observability-workshop/v5.78/css/auto-complete.css?1738773632 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/observability-workshop/v5.78/css/auto-complete.css?1738773632 rel=stylesheet></noscript><link href=/observability-workshop/v5.78/css/perfect-scrollbar.min.css?1738773632 rel=stylesheet><link href=/observability-workshop/v5.78/css/theme.min.css?1738773632 rel=stylesheet><link href=/observability-workshop/v5.78/css/format-print.min.css?1738773632 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../../../..",window.relearn.relBaseUri="../../../../../..",window.relearn.absBaseUri="https://splunk.github.io/observability-workshop/v5.78",window.relearn.min=`.min`,window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.themevariants=["auto","splunk-light","splunk-dark"],window.relearn.customvariantname="my-custom-variant",window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.localStorage.setItem(window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}}))},window.relearn.markVariant=function(){var t=window.localStorage.getItem(window.relearn.absBaseUri+"/variant"),e=document.querySelector("#R-select-variant");e&&(e.value=t)},window.relearn.initVariant=function(){var e=window.localStorage.getItem(window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.localStorage.setItem(window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant(),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><script src=https://cdn.signalfx.com/o11y-gdi-rum/latest/splunk-otel-web.js crossorigin=anonymous></script><script src=https://cdn.signalfx.com/o11y-gdi-rum/latest/splunk-otel-web-session-recorder.js crossorigin=anonymous></script><script>SplunkRum.init({realm:"us1",rumAccessToken:"dp3FKraOS_wVhe-l7eCOsA",applicationName:"observability-workshop",deploymentEnvironment:"splunk.github.io",version:"1.0"}),SplunkSessionRecorder.init({app:"observability-workshop",realm:"us1",rumAccessToken:"dp3FKraOS_wVhe-l7eCOsA"})</script></script><style>:root{--MAIN-WIDTH-MAX:130rem;--MENU-WIDTH-L:23rem}</style></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/observability-workshop/v5.78/en/ninja-workshops/10-advanced-otel/4-resilience/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div><div class="topbar-button topbar-button-toc" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Table of Contents (CTRL+ALT+t)"><i class="fa-fw fas fa-list-alt"></i></button><div class=topbar-content><div class=topbar-content-wrapper><nav class=TableOfContents><ul><li><ul><li><a href=#setup>Setup</a></li></ul></li></ul></nav></div></div></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/observability-workshop/v5.78/en/index.html><span itemprop=name>Splunk Observability Workshops</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/observability-workshop/v5.78/en/ninja-workshops/index.html><span itemprop=name>Ninja Workshops</span></a><meta itemprop=position content="2">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/observability-workshop/v5.78/en/ninja-workshops/10-advanced-otel/index.html><span itemprop=name>Advanced OpenTelemetry</span></a><meta itemprop=position content="3">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>4. Resilience</span><meta itemprop=position content="4"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-print" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/observability-workshop/v5.78/en/ninja-workshops/10-advanced-otel/4-resilience/index.print.html title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a></div><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/observability-workshop/v5.78/en/ninja-workshops/10-advanced-otel/3-filelog/3-2-test-filelog/index.html title="3.2 Test Filelog Receiver (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/observability-workshop/v5.78/en/ninja-workshops/10-advanced-otel/4-resilience/4-1-test-resilience/index.html title="4.1 Test Resilience (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div><div class="topbar-button topbar-button-more" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title=More><i class="fa-fw fas fa-ellipsis-v"></i></button><div class=topbar-content><div class=topbar-content-wrapper><div class="topbar-area topbar-area-more" data-area=more></div></div></div></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable ninja-workshops" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=4-building-in-resilience>4. Building In Resilience</h1><span class="badge cstyle primary badge-with-title"><span class=badge-title><i class="fa-fw fas fa-clock"></i></span><span class=badge-content>10 minutes</span>
</span>&nbsp;<p>We’ll explore how to use OpenTelemetry Collector’s <code>file_storage</code> extension to enhance the resilience of your telemetry pipeline. Specifically, we’ll demonstrate how this extension helps with checkpointing, managing retries, and handling temporary failures effectively.</p><p>By implementing this configuration, your OpenTelemetry Collector can reliably store intermediate states on disk, preventing data loss during network failures and enabling the collector to resume operations seamlessly.</p><details open class="box cstyle notices primary"><summary class=box-label><i class="fa-fw fas fa-lightbulb"></i>
Tip</summary><div class=box-content><p>This solution will work for metrics as long as the connection downtime is brief—up to 15 minutes. If the downtime exceeds this, the backend may still drop data due to timing mismatches. For logs, we’re planning to implement a more enterprise-ready solution in one of the upcoming collector releases.</p></div></details><h3 id=setup>Setup</h3><p>Create a new subdirectory named <code>4-resilience</code> and copy all contents from the <code>3-filelog</code> directory into it. Then, delete any <code>*.out</code> and <code>*.log</code> files. Your updated directory structure should now look like this:</p><div class=tab-panel data-tab-group=2d9aef62faecb39a0e859f220e34f5fa><div class=tab-nav><div class=tab-nav-title>&#8203;</div><button data-tab-item=updated-directory-structure class="tab-nav-button tab-panel-style cstyle initial active" tabindex=-1 onclick='switchTab("2d9aef62faecb39a0e859f220e34f5fa","updated-directory-structure")'>
<span class=tab-nav-text>Updated Directory Structure</span></button></div><div class=tab-content-container><div data-tab-item=updated-directory-structure class="tab-content tab-panel-style cstyle initial active"><div class=tab-content-text><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>WORKSHOP
</span></span><span class=line><span class=cl>├── 1-agent
</span></span><span class=line><span class=cl>├── 2-gateway
</span></span><span class=line><span class=cl>├── 3-filelog
</span></span><span class=line><span class=cl>├── 4-resilience
</span></span><span class=line><span class=cl>│   ├── agent.yaml
</span></span><span class=line><span class=cl>│   ├── gateway.yaml
</span></span><span class=line><span class=cl>│   ├── log-gen.sh (or .ps1)
</span></span><span class=line><span class=cl>│   └── trace.json
</span></span><span class=line><span class=cl>└── otelcol</span></span></code></pre></div></div></div></div></div><p>In this exercise, we will update the <code>agent.yaml</code> file by updating the <code>extensions:</code> section. This section is part of the OpenTelemetry configuration YAML, used to define optional components that enhance or modify the behavior of the OpenTelemetry Collector. These components do not handle telemetry data directly but provide additional capabilities or services to the Collector.</p><details open class="box cstyle notices green"><summary class=box-label><i class="fa-fw fas fa-running"></i>
Exercise</summary><div class=box-content><p>Our first task is to implement <strong>checkpointing</strong> using the <code>file_storage</code> extension. The <code>file_storage</code> extension ensures that the OpenTelemetry Collector can persist checkpoints to disk, which is especially useful in the event of network failures or restarts. This allows the Collector to resume from where it left off, without losing data.</p><ol><li><strong>Add <code>file_storage:</code> extension</strong> and name it <code>checkpoint:</code></li></ol><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=w>  </span><span class=nt>file_storage/checkpoint</span><span class=p>:</span><span class=w>      </span><span class=c># Extension Type/Name</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># Defines the directory where checkpoint files will be stored</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>directory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;./checkpoint-dir&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># Ensures that the directory is created if not exist </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>create_directory</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># Specifies timeout for file operations for checkpointing</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>timeout</span><span class=p>:</span><span class=w> </span><span class=l>1s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># Ensures that old checkpoint data is compacted periodically</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>compaction</span><span class=p>:</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c># Controls if compaction process begins at OpenTelemetry Collector startup               </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>on_start</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>   
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c># Specifies the directory used for compaction (as a midstep)        </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>directory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;./checkpoint-dir/tmp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c># Size limit for checkpoint transactions before compaction occurs</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>max_transaction_size</span><span class=p>:</span><span class=w> </span><span class=m>65536</span><span class=w>        </span></span></span></code></pre></div></div></details><p>The next exercise is modifying the <code>otlphttp:</code> exporter where retries and queuing are configured.</p><details open class="box cstyle notices green"><summary class=box-label><i class="fa-fw fas fa-running"></i>
Exercise</summary><div class=box-content><p><strong>Extend</strong> the existing <code>otlphttp</code> exporter:</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=w>  </span><span class=nt>otlphttp</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>endpoint</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;http://localhost:5318&#34;</span><span class=w> </span><span class=c># Gateway endpoint</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>headers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>X-SF-Token</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;FAKE_SPLUNK_ACCESS_TOKEN&#34;</span><span class=w> </span><span class=c># or your own token</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># Controls retrying when there is a failure in sending data</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>retry_on_failure</span><span class=p>:</span><span class=w>             
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>enabled</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>            </span><span class=c># Enables retrying</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># Configures an internal queue to store data that couldn&#39;t be sent</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>sending_queue</span><span class=p>:</span><span class=w>              
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>enabled</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>          </span><span class=c># Enables Sending queue</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c># Specifies the number of consumers reading from the queue</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>num_consumers</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>         
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>queue_size</span><span class=p>:</span><span class=w> </span><span class=m>10000</span><span class=w>      </span><span class=c># The maximum size of the queue</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c># Specifies queue state will be backed up in the file system</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>storage</span><span class=p>:</span><span class=w> </span><span class=l>file_storage/checkpoint</span></span></span></code></pre></div><p><strong>Update the <code>services</code> section</strong>: Add the <code>file_storage/checkpoint</code> extension to the existing <code>extensions:</code> section. This will cause the extension to be enabled:</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>service</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>extensions</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=l>health_check,file_storage/checkpoint].</span><span class=w> </span><span class=c># Enabled extensions for this collector   </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>pipelines</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c>#traces:</span></span></span></code></pre></div><p>As we want to control the data flow for this exercise we are going to temporarily remove the <code>hostmetrics</code> receiver from the Metric pipeline:</p><p><strong>Update the <code>metrics</code> pipeline</strong>: Remove the <code>hostmetrics</code> receiver from <code>metrics</code> pipeline in the <code>service</code> section like this:</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=w>  </span><span class=nt>metrics</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=nt>receivers</span><span class=p>:</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=l>otlp                       </span><span class=w> </span><span class=c># OTLP Receiver</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=c>#hostmetrics                 # Hostmetrics Receiver</span></span></span></code></pre></div></div></details><p>Again, validate the agent configuration using <a href=https://www.otelbin.io/ rel=external target=_blank><strong>otelbin.io</strong></a> for spelling mistakes etc. Your <code>metrics:</code> pipeline should like this:</p><pre class="mermaid align-center">%%{init:{&#34;fontFamily&#34;:&#34;monospace&#34;}}%%
graph LR
    %% Nodes
      REC1(&amp;nbsp;&amp;nbsp;otlp&amp;nbsp;&amp;nbsp;&lt;br&gt;fa:fa-download):::receiver
      REC2(filelog&lt;br&gt;fa:fa-download):::receiver
      PRO1(memory_limiter&lt;br&gt;fa:fa-microchip):::processor
      PRO2(resourcedetection&lt;br&gt;fa:fa-microchip):::processor
      PRO3(resource&lt;br&gt;fa:fa-microchip):::processor
      PRO4(batch&lt;br&gt;fa:fa-microchip):::processor
      EXP1(&amp;ensp;debug&amp;ensp;&lt;br&gt;fa:fa-upload):::exporter
      EXP2(otlphttp&lt;br&gt;fa:fa-upload):::exporter
    %% Links
    subID1:::sub-logs
    subgraph &#34; &#34;
      subgraph subID1[**Logs**]
      direction LR
      REC1 --&gt; PRO1
      REC2 --&gt; PRO1
      PRO1 --&gt; PRO2
      PRO2 --&gt; PRO3
      PRO3 --&gt; PRO4
      PRO4 --&gt; EXP1
      PRO4 --&gt; EXP2
      end
    end
classDef receiver,exporter fill:#8b5cf6,stroke:#333,stroke-width:1px,color:#fff;
classDef processor fill:#6366f1,stroke:#333,stroke-width:1px,color:#fff;
classDef con-receive,con-export fill:#45c175,stroke:#333,stroke-width:1px,color:#fff;
classDef sub-logs stroke:#34d399,stroke-width:1px, color:#34d399,stroke-dasharray: 3 3;</pre><p>This setup enables your OpenTelemetry Collector to handle network interruptions smoothly by storing telemetry data on disk and retrying failed transmissions. It combines checkpointing for recovery with queuing for efficient retries, enhancing the resilience and reliability of your pipeline. Now, let’s test the configuration!</p><footer class=footline><span class="badge cstyle note badge-with-title"><span class=badge-title class=text-muted>Last Modified
</span><span class=badge-content>Feb 5, 2025</span></span></footer></article><section><h1 class=a11y-only>Subsections of 4. Resilience</h1><article class=default><header class=headline></header><h1 id=41-test-resilience>4.1 Test Resilience</h1><h3 id=setup-test-environment>Setup Test environment</h3><p>In this section we are going to simulate an outage on the network between the <strong>Agent</strong> and the <strong>Gateway</strong> and see if our configuration helps the Collector recover from that issue:</p><details open class="box cstyle notices green"><summary class=box-label><i class="fa-fw fas fa-running"></i>
Exercise</summary><div class=box-content><p><strong>Run the Gateway</strong>:
Find your <strong>Gateway</strong> terminal window, and navigate to the <code>[WORKSHOP]/4-resilience</code> directory and restart the gateway.</p><p>It should start up normally and state : <code>Everything is ready. Begin running and processing data.</code></p><p><strong>Run the Agent</strong>:
Find your <strong>Agent</strong> terminal window and navigate to the <code>[WORKSHOP]/4-resilience</code> directory and restart the agent with the resilience configurations specified in the YAML file.</p><p>It should also start up normally and state : <code>Everything is ready. Begin running and processing data.</code></p><p><strong>Send a Test Trace</strong>:<br>Find your <code>Test</code> terminal window and navigate to the <code>[WORKSHOP]/4-resilience</code> directory. From there, send a test trace to confirm that communication is functioning as expected.</p><p>Both the agent and gateway should display debug information, including the trace you just sent. Additionally, the gateway should generate a new <code>./gateway-traces.out</code> file.</p><p>If everything is working as expected, we can move on to testing the system’s resilience.</p></div></details><h3 id=testing-system-resilience>Testing System Resilience</h3><p>To evaluate the system’s resilience, we’ll simulate a scenario where the <strong>Gateway</strong> becomes temporarily unreachable by stopping it and observing how the system responds. First, we’ll generate traffic to the agent by sending some traces. Since the <strong>Gateway</strong> is down, the agent will enter retry mode. Once we restart the agent, it will recover the traces from the persistent queue and successfully send them to the Gateway. Without the persistent queue, these traces would have been lost permanently.</p><details open class="box cstyle notices green"><summary class=box-label><i class="fa-fw fas fa-running"></i>
Exercise</summary><div class=box-content><p>Let&rsquo;s start our &ldquo;network failure&rdquo;:</p><p><strong>Simulate a Network Failure</strong>:
Stop the <strong>Gateway</strong> with <code>Ctrl-C</code> and wait until the gateway console shows that it has stopped:</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>2025-01-28T13:24:32.785+0100  info  service@v0.116.0/service.go:309  Shutdown complete.</span></span></code></pre></div><p><strong>Create Traffic during the &ldquo;Network Failure&rdquo;</strong>:<br>While the <strong>Gateway</strong> is stopped, send 3–4 traces using the cURL command we used earlier.</p><p>Notice that the agent’s retry mechanism is activated as it continuously attempts to resend the data. In the agent’s console output, you will see repeated messages similar to the following:</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>2025-01-28T14:22:47.020+0100  info  internal/retry_sender.go:126  Exporting failed. Will retry the request after interval.  {&#34;kind&#34;: &#34;exporter&#34;, &#34;data_type&#34;: &#34;traces&#34;, &#34;name&#34;: &#34;otlphttp&#34;, &#34;error&#34;: &#34;failed to make an HTTP request: Post \&#34;http://localhost:5318/v1/traces\&#34;: dial tcp 127.0.0.1:5318: connect: connection refused&#34;, &#34;interval&#34;: &#34;9.471474933s&#34;}</span></span></code></pre></div><p><strong>Stop the Agent</strong>:<br>Use &lsquo;Ctrl-C&rsquo; to stop the agent. Wait until the agent’s console confirms it has stopped.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>2025-01-28T14:40:28.702+0100  info  extensions/extensions.go:66  Stopping extensions...
</span></span><span class=line><span class=cl>2025-01-28T14:40:28.702+0100  info  service@v0.116.0/service.go:309  Shutdown complete.</span></span></code></pre></div><details open class="box cstyle notices primary"><summary class=box-label><i class="fa-fw fas fa-lightbulb"></i>
Tip</summary><div class=box-content><p>Stopping the agent will halt its retry attempts and prevent any future retry activity.</p><p>If the agent runs for too long without successfully delivering data, it may begin dropping traces, depending on the retry configuration, to conserve memory. By stopping the agent, any metrics, traces, or logs currently stored in memory are lost before being dropped, ensuring they remain available for recovery.</p><p>This step is essential for clearly observing the recovery process when the agent is restarted.</p></div></details><p><strong>Simulate Network Recovery</strong>:<br>Restart the Gateway. It should initialize as expected and be ready and waiting to receive data.</p><p><strong>Restart the Agent</strong>
Once the <strong>Gateway</strong> is up and running, restart the <strong>Agent</strong>. It will resume sending data from the last checkpointed state, ensuring no data is lost. You should see the <strong>Gateway</strong> begin receiving the previously missed traces without requiring any additional action on your part.</p><details open class="box cstyle notices primary"><summary class=box-label><i class="fa-fw fas fa-lightbulb"></i>
Tip</summary><div class=box-content><p>Note that only the <strong>Gateway</strong> will show that the checkpointed traces have arrived. The agent will not display any indication that data new or old has been sent.</p></div></details></div></details><h3 id=conclusion>Conclusion</h3><p>This exercise demonstrated how to enhance the resilience of the OpenTelemetry Collector by configuring the <code>file_storage</code> extension, enabling retry mechanisms for the OTLP exporter, and using a file-backed queue for temporary data storage.</p><p>By implementing file-based checkpointing and queue persistence, you ensure the telemetry pipeline can gracefully recover from temporary interruptions, making it a more robust and reliable for production environments.</p><p>If you want to know more about the <code>FileStorage</code> extension, you can find it <a href=https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/extension/storage/filestorage rel=external target=_blank><strong>here</strong></a>.</p><p>Stop the <strong>Agent</strong> and <strong>Gateway</strong> using <code>Ctrl-C</code>.</p><footer class=footline><span class="badge cstyle note badge-with-title"><span class=badge-title class=text-muted>Last Modified
</span><span class=badge-content>Feb 5, 2025</span></span></footer></article></section></div></main></div><script src=/observability-workshop/v5.78/js/clipboard.min.js?1738773632 defer></script><script src=/observability-workshop/v5.78/js/perfect-scrollbar.min.js?1738773632 defer></script><script src=/observability-workshop/v5.78/js/d3/d3-color.min.js?1738773632 defer></script><script src=/observability-workshop/v5.78/js/d3/d3-dispatch.min.js?1738773632 defer></script><script src=/observability-workshop/v5.78/js/d3/d3-drag.min.js?1738773632 defer></script><script src=/observability-workshop/v5.78/js/d3/d3-ease.min.js?1738773632 defer></script><script src=/observability-workshop/v5.78/js/d3/d3-interpolate.min.js?1738773632 defer></script><script src=/observability-workshop/v5.78/js/d3/d3-selection.min.js?1738773632 defer></script><script src=/observability-workshop/v5.78/js/d3/d3-timer.min.js?1738773632 defer></script><script src=/observability-workshop/v5.78/js/d3/d3-transition.min.js?1738773632 defer></script><script src=/observability-workshop/v5.78/js/d3/d3-zoom.min.js?1738773632 defer></script><script src=/observability-workshop/v5.78/js/js-yaml.min.js?1738773632 defer></script><script src=/observability-workshop/v5.78/js/mermaid.min.js?1738773632 defer></script><script>window.themeUseMermaid=JSON.parse("{}")</script><script src=/observability-workshop/v5.78/js/theme.js?1738773632 defer></script></body></html>